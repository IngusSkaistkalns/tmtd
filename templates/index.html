{% extends "layout.html" %} {% block title %}Home - TMTD{% endblock %} {% block
content %}
<div class="row">
  <div class="col-lg-8 mx-auto">
    <div class="card shadow">
      <div class="card-body">
        <h1 class="card-title text-center mb-4">
          <i class="bi bi-pencil-square"></i> Tell Me The Digit
        </h1>
        <p class="text-center text-muted mb-4">
          Draw a digit and let our AI recognize it!
        </p>

        <div class="text-center">
          <canvas
            id="drawingCanvas"
            class="border border-2 rounded"
            width="280"
            height="280"
            style="cursor: crosshair"
          ></canvas>
        </div>

        <div class="mt-4 d-flex justify-content-center gap-2">
          <button class="btn btn-primary" id="predictBtn">
            <i class="bi bi-cpu"></i> Predict
          </button>
          <button class="btn btn-secondary" id="clearBtn">
            <i class="bi bi-arrow-clockwise"></i> Clear
          </button>
        </div>

        <div id="result" class="mt-4 text-center" style="display: none">
          <h3>
            Prediction:
            <span id="prediction" class="badge bg-success fs-3"></span>
          </h3>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  const canvas = document.getElementById("drawingCanvas");
  const ctx = canvas.getContext("2d");
  let isDrawing = false;

  // Set up canvas
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = "black";
  ctx.lineWidth = 15;
  ctx.lineCap = "round";

  // Drawing functions
  function startDrawing(e) {
    isDrawing = true;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    ctx.beginPath();
    ctx.moveTo(x, y);
  }

  function draw(e) {
    if (!isDrawing) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    ctx.lineTo(x, y);
    ctx.stroke();
  }

  function stopDrawing() {
    isDrawing = false;
  }

  // Mouse events
  canvas.addEventListener("mousedown", startDrawing);
  canvas.addEventListener("mousemove", draw);
  canvas.addEventListener("mouseup", stopDrawing);
  canvas.addEventListener("mouseout", stopDrawing);

  // Touch events for mobile
  canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent("mousedown", {
      clientX: touch.clientX,
      clientY: touch.clientY,
    });
    canvas.dispatchEvent(mouseEvent);
  });

  canvas.addEventListener("touchmove", (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent("mousemove", {
      clientX: touch.clientX,
      clientY: touch.clientY,
    });
    canvas.dispatchEvent(mouseEvent);
  });

  canvas.addEventListener("touchend", (e) => {
    e.preventDefault();
    const mouseEvent = new MouseEvent("mouseup", {});
    canvas.dispatchEvent(mouseEvent);
  });

  // Clear button
  document.getElementById("clearBtn").addEventListener("click", () => {
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    document.getElementById("result").style.display = "none";
  });

  // Predict button
  document.getElementById("predictBtn").addEventListener("click", () => {
    const imageData = canvas.toDataURL("image/png");

    fetch("/", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ image: imageData }),
    })
      .then((response) => response.json())
      .then((data) => {
        document.getElementById("prediction").textContent =
          data.prediction || "?";
        document.getElementById("result").style.display = "block";
      })
      .catch((error) => {
        console.error("Error:", error);
        alert("Error predicting digit. Please try again.");
      });
  });
</script>
{% endblock %}
